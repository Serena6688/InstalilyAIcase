# PartSelect Parts Assistant (LLM-assisted, stateful router)

A demo backend for an **appliance parts assistant** focused on **dishwashers and refrigerators**, supporting:

- Part compatibility checks (PS part â†” model)
- Step-by-step installation guidance
- Structured troubleshooting flows
- Basic order / human handoff (demo)
- **Deterministic dialog routing with selective LLM augmentation (Groq)**

This project intentionally combines **rule-based dialog control** with **LLM parsing only where it adds value**, to avoid common â€œchatbot driftâ€ problems.

---

## âœ¨ Why this project exists

Most LLM chatbots struggle with:
- Losing context across short follow-ups (â€œclampsâ€, â€œsideâ€, â€œyesâ€)
- Jumping intents unexpectedly (install â†’ part lookup â†’ home)
- Over-using LLMs where simple logic would be more reliable

This project demonstrates a **hybrid approach**:

> **State machine + intent router first**  
> **LLM only as a fallback for ambiguous human language**

---

## ğŸ§  Architecture Overview

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Frontend â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
â”‚ message + history
â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ router.ts          â”‚  â† main brain
â”‚  - intent inferenceâ”‚
â”‚  - appliance pin   â”‚
â”‚  - dialog state    â”‚
â”‚  - stickiness      â”‚
â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â”œâ”€ deterministic flows (most cases)
â”‚
â””â”€ Groq (only if needed)
â””â”€ groqHelpers.ts

Key idea: **the LLM never decides the dialog flow** â€” it only helps parse *ambiguous natural language* when rules fail.

---

## ğŸ§© Core Concepts

### 1. Intent Stickiness (No Intent Stealing)

Short replies like:

- `panel`
- `clamps`
- `side`
- `yes`
- `totally stuck`

are **consumed by the current flow**, instead of being re-classified as new intents.

This prevents classic bugs like:
> User: *â€œclampsâ€*  
> Bot: *â€œHereâ€™s part PS11752778â€*

---

### 2. Appliance Pinning

The assistant infers and **pins the appliance** (dishwasher vs refrigerator) across turns, even if the user stops mentioning it explicitly.

Example:

User: My dishwasher is not draining
User: yes
User: humming

The system still knows this is a **dishwasher drain flow**.

---

### 3. Explicit Dialog State Machine

The router tracks fine-grained awaiting states such as:

- `install_step`
- `clamp_type`
- `panel_still_wont_drop_yesno`
- `connector_moving_or_stuck`
- `pump_sound`
- `dishwasher_drain_speed`

Each user reply is first offered to the **current awaiting state** before any re-routing.

---

## âš¡ Where Groq Is Used (on purpose)

Groq is **not** used to â€œchatâ€.

It is only used when:
- The system expects a specific semantic answer
- Rule-based parsing fails

### Example: Drain Pump Sound

User input:

â€œIt makes a weird buzzing noiseâ€

Rule-based parser â†’ `unknown`  
Groq fallback â†’ `"humming"`

This allows the flow to continue **without giving Groq control of the dialog**.

```ts
// router.ts
if (ps === "unknown") {
  const llm = await groqParsePumpSound(message);
  if (llm !== "unknown") ps = llm;
}


â¸»

ğŸ“‚ Project Structure

src/
â”œâ”€ router.ts          # main dialog router & state machine
â”œâ”€ groqHelpers.ts     # narrow LLM helpers (classification only)
â”œâ”€ tools.ts           # demo tools (compatibility, lookup, guides)
â”œâ”€ types.ts           # ChatRequest / ChatResponse / Intent


â¸»

â–¶ï¸ Running the Project

npm install
npm run dev

Backend runs at:

http://localhost:8080


â¸»

ğŸ”‘ Environment Variables

GROQ_API_KEY=your_api_key_here

If the key is missing, the system still works â€” Groq is optional and only used as a fallback.

